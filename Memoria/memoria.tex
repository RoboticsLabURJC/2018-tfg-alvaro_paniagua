%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX

\title{Memoria del Proyecto}
\author{Álvaro Paniagua Tena}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} 
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
INGENIERÍA EN SISTEMAS AUDIOVISUALES Y MULTIMEDIA

\vspace{0.4cm}

\large
Curso Académico 2018/2019

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\Large
WEBSIM \\
SIMULADOR DE ROBOTS CON TECNOLOGÍAS WEB VR

\vspace{4cm}

\large
Autor : Álvaro Paniagua Tena \\
Tutor : Dr. Jose María Cañas Plaza
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Título del Trabajo con Letras Capitales para Sustantivos y Adjetivos

\vspace{1cm}
\large
\textbf{Autor :} Álvaro Paniagua Tena \\
\textbf{Tutor :} Dr. Jose María Cañas Plaza

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 20XX, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 20XX
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mis padres, familia, y a mi pareja Cristina}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado

En primer lugar dar las gracias a mis padres por apoyarme y animarme 
desde el primer momento. También agradecer a mis compañeros Roberto, 
Ángel y Ahmed por tantas horas de ayuda y clases particulares para que 
entendiese todo bien.

Gracias tambien a Jose María Cañas por darme la oportunidad de 
colaborar en el proyecto.

Por último dar las gracias a mi pareja Cristina, has sido un gran apoyo 
en estos últimos años y sin duda me has motivado a hacer mejor las 
cosas y superarme.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

El proyecto tiene una intención clara, la creación de un simulador de 
robots usando tecnologías web puras aprovechando el crecimiento que ha 
experimentado el framework \emph{AFRAME}.\\

Para la realización del proyecto se han utilizado diversas tecnologías 
como \emph{HTML5}, \emph{JavaScript}, \emph{CSS3}, \emph{AFRAME}, 
\emph{jQuery} y \emph{Blockly (Scratch 3)}. \\

El proyecto pretende ser una herramienta para la plataforma JdeRobot 
Kids en la cual los alumnos pueden generar código en el simulador 
\textbf{WebSim} para resolver una serie de ejercicios introductorios
sobre \textbf{visión artificial} y \textbf{programación de robots} 
brindandoles varias opciones para dicha generación de código:

\begin{itemize}
	\item Escribiendo código en JavaScript puro a través de un editor 
	de código embebido.
	\item Utilizando el lenguaje de bloques visuales Scratch 3, este a 
	su vez se puede probar en el propio simulador ya que se traduce a 
	JavaScript nativo o bien exportarlo para probarlo en el robot 
	físico, esto es posible gracias a la traducción de Scratch 3 a 
	\emph{Python}.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

This project has a clear intention, create a robot simulator using web
tecnologies taking advantage of the \emph{AFRAME} framework growth.\\

For the ralization of the project, different tecnologies have been 
used, such as \emph{HTML5}, \emph{JavaScript}, \emph{CSS3}
\emph{AFRAME}, \emph{jQuery} and\emph{Blockly (Scratch 3)}.\\

The project aims to be a tool for the JdeRobot Kids platform on which 
students can generate code on WebSim simulator to solve basic exercises 
on \textbf{artificial vision} and \textbf{robot programming} bringing 
them different options to generate this code:

\begin{itemize}
	\item Writing code on JavaScript lenguage through the embedded code 
	editor inside the web page.
	\item Using the visual block language Scratch 3, this in turn can 
	be tested inside the simulator itself as it is translated to 
	JavaScript language or can be export the code to test it on the 
	physical robot translating Scratch 3 to \emph{Python} code.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{chap:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

Este Trabajo Fin de Grado tiene como objetivo la creación de una herramienta de simulación de robots para la plataforma JdeRobot Kids.

\section{Contexto}
\label{sec:contexto}

El desarrollo tecnológico ha generado cambios a nivel social facilitandonos a las personas
la mayoría de las tareas que llevamos a cabo a lo largo del día tanto dentro del trabajo
como pueden ser largas cadenas automáticas de fabricación de productos como en el ámbito
del hogar como es el caso del aspirador Roomba.\\

La tendencia actual en robótica es la de tener robots que tengan un nivel de funcionalidad 
igual al que pueda tener un humano, con esto nos referimos a moverse de la misma manera
que un humano, detectar los distintos objetos que conforman nuestro entorno e incluso 
detectar a las distintas personas de una sala. Este nuevo paradigma acarrea la necesidad
de formar a nuevos expertos en éste área lo que conlleva la formación desde edades más 
tempranas.

\subsection{Motivación}
\label{subsec:motivacion}

La motivación de este proyecto es la de sustituir el presente simulador \emph{Gazebo} por
WebSim, un simulador desarrollado íntegramente con tecnologías Web con peso computacional
en el lado cliente lo que permite escalar el número de usuarios que lo utilizan de manera
simultánea.

\subsection{Motivación personal}
\label{subsec:motivacion_personal}

Como motivación personal decir que, desde el inicio del grado me ha gustado el mundo de la
programación y el desarrollo web.

Además, me gusta poder ayudar al aprendizaje de los demás por tanto este proyecto creo que
encaja a la perfección ambos aspectos.



\section{Estructura de la memoria}
\label{sec:estructura}

En esta sección se detalla la esctura de la memoria que constará de las siguientes partes:

\begin{itemize}
  \item El capítulo~\ref{chap:intro} es una introducción al proyecto 
  donde se explica la motivación del proyecto y la motivación personal.

  \item En el capítulo~\ref{chap:objetivos} se muestran los objetivos a 
  completar para la elaboración del proyecto y la estructura del
  \textbf{roadmap}.

  \item En el capítulo~\ref{chap:estado_arte} se presentan las 
  tecnólogias que se han utilizado para el desarrollo del proyecto y se 
  explica el porqué de dichas tecnologías y no otras.

  \item En el capítulo~\ref{chap:disenno} se explicarán el diseño de la 
  aplicación, soporte del robot, es decir, qué funcionalidades tiene y 
  la conectividad que dispone el simulador.
  
  \item En el capítulo~\ref{chap:usos} se muestran las aplicaciones 
  reales en las que se encuentra actualmente WebSim.
  
  \item Finalmente en el capítulo~\ref{chap:conclusiones} se hace una 
  valoración de todo lo que ha conllevado el proyecto y se proponen 
  futuras implementaciones o mejoras de WebSim.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo_general} % identificador de sección (no se muestra, es para poder referenciarla)

Mi trabajo fin de grado consiste en crear la base de una herramienta educativa para 
simulación de robots para la plataforma JdeRobot Kids en la cual el peso computacional la 
lleve el lado cliente en lugar del lado servidor.


\section{Objetivos específicos}
\label{sec:objetivos_especificos}

El objetivo específico de el proyecto es la simulación del robot 
\textbf{PiBot} implementando así todo su conjunto de sensores y 
actuadores en los que se encuentran:

\begin{itemize}
	\item \textbf{Motores}: son dos servomotores independientes que 
	dotan de movimiento al robot.
	
	\item \textbf{Cámara}: una minicámara, ésto le da funcionalidad muy 
	importante al robot como puede ser la detección de obstáculos.
	
	\item \textbf{Sensores IR}: dos sensores infrarrojos posicionados 
	en la parte baja del chasis del robot, estos sensores permiten la 
	detección de colores, objetos y formas.
	
	\item \textbf{Sensor de ultrasonidos}: Dos sensores de ultrasonido 
	posicionados en la parte delantera del chasis del robot, su 
	funcionalidad es la de sensores de proximidad lo que permite saber 
	no solo si hay un objeto delante sino que también permite saber
	a qué distancia está dicho objeto.
	
\end{itemize}


\section{Planificación temporal}
\label{sec:planificacion_temporal}

A continuación se muestran tres imágenes que representan la 
planificación temporal 

\begin{figure}

  \includegraphics[width=\linewidth]{img/GANTT-1.PNG}
  \caption{Diagrama de GANTT para el rango de fechas 14 de Julio de 
  2018 al 1 de Septiembre de 2018.}
  \vspace{1.5cm}
  
  \includegraphics[width=\linewidth]{img/GANTT-2.PNG}
  \caption{Diagrama de GANTT para el rango de fechas 2 de Septiembre de 
  2018 al 21 de Octubre de 2018.}
  \vspace{1.5cm}
  
  \includegraphics[width=\linewidth]{img/GANTT-3.PNG}
  \caption{Diagrama de GANTT para el rango de fechas 22 de Octubre de 
  2018 al 28 de Octubre de 2018.}
  
  \label{fig:gantt}
  
\end{figure}

El nivel de esfuerzo para este proyecto ha sido alto debido a la 
necesidad de aprender diferentes tecnologías como son AFRAME, jQuery y
OpenCVjs. Se dedicaban alrededor de 3-4 horas al día cada día de la 
semana a excepción de los fines de semana que se añadían 2 horas más 
al anterior intervalo.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE (FRAMEWORKS) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Estado del arte}
\label{chap:estado_arte}

\section{¿Por qué tecnologías WEB?}
\label{sec:WEB}

En la siguiente sección se tratarán de explicar las razones por las 
cuales se ha elegido desarrollar el proyecto con tecnologías web.

La principal y creo que más importante de las ventajas que ofrecen las
tecnologías web es la ausencia de necesidad de instalación de paquetes
de software, configuración y dependencias. Basta con tener un navegador,
en este caso Firefox, y una conexión a internet, todos los archivos 
necesarios para la ejecución de la aplicación se sirven de manera 
automática al ingresar la URL dentro de la barra de navegación.

El cliente no tiene la necesidad de instalar actualizaciones 
ya que únicamente se actualiza la versión que proporciona el servidor,
esto elimina las incompatibilidades entre versiones ya que todos los
clientes usarán la misma versión.
Desarrollo unificado, con esto hacemos referencia a que no se necesita
desarrollar para los distintos sistemas operativos (Windows, MacOS,
Linux/Ubuntu, etc.) así como conocer sus entornos gráficos y 
dependencias del sistema operativo, lo único necesario es saber HTML5, 
JavaScript y CSS3 , el navegador se encarga de interpretar los
distintos lenguajes.

No todo son ventajas, como desventaja sabemos que las aplicaciones 
web son algo más lentas debido a la necesidad de descargar los recursos
y no ser lenguajes binarios como C++ o Java sino interpretados, ésta 
desventaja cada vez va siendo menor debido a las mejoras en los 
navegadores y protocolos como por ejemplo \emph{AJAX (Asynchronous 
JavaScript and XML requests} que trata de una técnica de peticiones 
ligeras para aplicaciones interactivas.

Además con los años ha aumentado el número de navegadores distintos y
desarrollar la aplicación para todos ellos es costoso aunque existen
frameworks que facilitan esta tarea como pueden ser Express y Loopback
para el lenguaje JavaScript y Django para el lenguaje Python.\\ 

Como conclusión, las tecnologías web están avanzando cada vez más 
con el objetivo de llegar al rendimiento de las aplicaciones de 
escritorio hasta el punto de existir frameworks para el desarrollo de
aplicaciones híbridas, es decir, desarrolladas con lenguaje web pero 
haciendo uso del sistema operativo como es el caso de \emph{Electron}.

\newpage
\section{JavaScript}
\label{sec:javascript}

\textbf{\emph{JavaScript}} fue creado por Brendan Eich en 1995 cuando
trabajaba para Netscape Communications inspirado por el lenguaje Java.

\emph{\textbf{JavaScript}} es un lenguaje con las siguientes características 
principales:

\begin{itemize}
	\item Lenguaje de \textbf{alto nivel}, esto quiere decir que su 
	sintaxis es similar a la escritura habitual de una persona, por 
	ejemplo:
	\begin{lstlisting}
	function myFunction(){
		console.log("Hello world");	
	}
	\end{lstlisting}
	
	\item Lenguaje basado en \textbf{objetos}, esto es una estructura
	habitual en programación que se refiere a la encapsulación de 
	operaciones y estados en un modelo de datos. Otros lenguajes 
	orientados a objetos serían \emph{Python, Ruby, Java, etc.} La
	figura ~\ref{fig:objeto-javascript} representa de manera visual la orientación a 
	objetos.
	\begin{figure}[h]
		\centering
		\includegraphics[width=6cm, height=3.5cm]
		{img/objects_and_classes.png}
		
		\caption{En la parte izquierda de la imagen se muestra el 
		objeto \textbf{coche} del que heredan los 3 de la parte
		derecha de la imagen, los 3 coches tienen en común que son
		del objeto coche pero se diferencian en \textbf{marca} y
		\textbf{color.}}
		
		\label{fig:objeto-javascript}
	\end{figure}
\end{itemize}

Es el lenguaje más utilizado para el desarrollo Web, permite que las aplicaciones web 
sean interactivas, es decir, permite hacer actualizaciones de contenido en el momento, 
mostrar mapas, animaciones 3D. Es el tercer pilar del estándar de tecnologías web 
compuesto por \textbf{\emph{HTML, CSS y JS}}.

Este lenguaje tiene mucho peso en el lado cliente, es decir, en el código que se 
ejecuta en el navegador pero gracias a la entrada de NodeJS cuando éste lenguaje ha 
obtenido más peso dentro del desarrollo web ya que NodeJS permite la creación de
servidores de manera sencilla.

Actualmente \textbf{JavaScript} se utiliza en multitud de frameworks tanto de lado 
cliente como en el lado servidor, a continuación se enumeran algunos de los más usados:

\begin{itemize}
	\item \textbf{NodeJS}: Tecnología en el lado servidor con código completamente 
	JavaScript asíncrono y orientado a eventos, NodeJS fué diseñado para construir 
	aplicaciones en red escalables. Su principal característica es la capacidad de 
	gestionar multitud de conexiones simultáneas de una manera muy eficaz gracias a su
	arquitectura. Se basa en un hilo que escucha peticiones y las redirecciona a 
	\textbf{hebras} distintas, cada una de estas hebras ejecuta el código necesario y
	una vez la hebra termina lanza un evento al hilo de peticiones indicando que ha 
	terminado de ejecutar la tarea indicada entonces es el hilo de peticiones el que se
	encarga de devolver la respuesta.
	
	\item \textbf{Express y Loopback}: Ambos frameworks son extensiones de NodeJS y 
	permiten la creación de un API en el lado servidor. Loopback es actualmente más 
	importante que Express ya que ofrece muchas herramientas para la creación de
	API Rest de manera muy sencilla así como conectores a la mayoría de bases de datos
	como puede ser MongoDB, mySQL, sqlite3, etc.
	
	\item \textbf{AngularJS} Es un framework basado en el \emph{Modelo Vista Controlador}
	para el desarrollo en la parte cliente que permite la creación de aplicaciones web
	\textbf{SPA} (\emph{Simple-Page-Application}). AngularJS permite extender el 
	lenguaje HTML con directivas y atributos sin perder la semántica.
	
	\item \textbf{AFRAME} Es un framework de creación de escenas de 
	\emph{Realidad Virtual}, se hablará de manera más extensa en el apartado ~
	\ref{sec:aframe}. No es un framework muy extendido debido a su juventud pero
	cuenta con una gran comunidad de desarrolladores y es el pilar central 
	del proyecto que se lleva a cabo.
\end{itemize}

Esta imagen creada de los frameworks disponibles para JavaScript sirve como 
respaldo ante la decisión de elegir el lenguaje. Además como se ha comentado en la 
subsección ~\ref{subsec:motivacion} el proyecto se orienta a la creación de una 
aplicación con peso en el lado cliente, por tanto sabiendo ésto y teniendo en cuenta que
AFRAME está creado en el lenguaje JavaScript la elección de este lenguaje gana peso por
sí sola.

\newpage
\section{HTML}
\label{sec:html}

\textbf{\emph{HTML}} fue creado por \emph{Tim Berners-Lee} en 1990 y es el acrónimo para
\emph{HyperText Markup Language} (Lenguaje de marcas de hipertexto). 

Se utiliza para la creación de documentos electrónicos que se envían a través de la red
global (internet). Cada documento tiene una serie de conexiones a otros documentos 
llamados \textbf{\emph{hyperlinks}} que permiten la navegación entre distintos recursos.

\textbf{HTML} asegura el formato correcto de texto, imágenes y estilos para poder leer
un documento con el navegador con la forma original con la que se generó el documento. En
la figura ~\ref{fig:estructura-html} se muestra una página HTML muy simple y se explican 
sus distintas partes y su función.

\begin{figure}[h]
	\centering
	\includegraphics[width=9.5cm, height=4.5cm]{img/html-ejemplo.png}
	\caption{Estructura de una pagina HTML simple con un título y un párrafo}
	
	\label{fig:estructura-html}
\end{figure}

Como vemos en la figura anterior,un documento HTML tiene una estructura de árbol donde
la etiqueta \textbf{html} es el elemento raíz y cada nuevo elemento es una rama del anterior. 

Como elementos principales del documento HTML tenemos la declaración documento
\textbf{DOCTYPE html} que en este caso indica que estamos ante un documento
HTML 5 que es última versión de HTML. Como hemos indicado en el párrafo anterior la 
etiqueta \textbf{html} marca la raíz del documento, dentro de ésta etiqueta tenemos dos 
etiquetas importantes:

\begin{itemize}
	\item \textbf{HEAD} es la cabecera del documento, contiene los metadatos del documento
	como el título, la codificación de caracteres utilizada y links a otros recursos 
	adicionales como pueden ser \emph{scripts} y \emph{hojas de estilos}.
	
	\item \textbf{BODY} es el contenido que se mostrará del documento, puede contener
	imágenes, enlaces a otros documentos, vídeos, menús de navegación, formularios, 
	botones e incluso escenas animadas como la que se mostrará en el presente proyecto.
\end{itemize}

Las combinaciones de elementos son muy amplias, no existe una única estructura válida para
un documento HTML sino que se genera una estructura en función de la aplicación.

Dentro del estándar HTML se ha escogido el estándar HTML5, a continuación se enumeran 
las nuevas características de éste nuevo estándar que tienen relación con el proyecto:

\begin{itemize}
	\item \textbf{VIDEO}, esta etiqueta es una de las nuevas características
	de HTML5 y una de las más importantes, permite embeber vídeos dentro de una página 
	web de manera nativa sin el uso de \emph{plugins}.
	
	\item \textbf{NAV}, esta etiqueta declara un elemento de tipo \emph{barra de
	navegación} en el cual se encuentra el menú con enlaces a otros tipos de recursos
	y secciones tanto dentro como fuera de la página. En nuestro caso esta etiqueta se ha
	utilizado para encapsular los botones de arranque/pare del código creado por el alumno
	y el botón que permite mostrar u ocultar la cámara del robot.
	
	\item \textbf{CANVAS}, permite la renderización de escenas gráficas a través de 
	JavaScript. Es la etiqueta más importante dentro de nuestro proyecto ya que es la
	etiqueta que nos permite la creación de la escena en la cual tenemos nuestro 
	robot simulado.
\end{itemize}

Existe una característica importante que afecta a todo el documento de HTML5 pero que,
en general, no se está respetando en el desarrollo web y es que HTML5 tiene una tendencia
semántica, es decir, las etiquetas como \textbf{SECTION, NAV y FOOTER} marcan claramente
zonas dentro del documento HTML con el fin de poder conocer la estructura del documento
de manera clara.


\newpage
\section{CSS}
\label{sec:css}

\textbf{\emph{CSS}} o \emph{Cascading StyleSheet} es un lenguaje que se usa para definir
el aspecto visual de una página HTML. Su principal misión es la de separar la estructura
y contenido del aspecto de la pagina HTML.\\

Con \textbf{CSS} podemos controlar incluso cómo se van a ver todos los documentos HTML de
mi aplicación, es comúnmente utilizado por las empresas y diseñadores gráficos para crear
de manera visual una identificación de la aplicación mediante tipos de letra, paleta de
colores utilizada.

Deja atrás la gran necesidad de uso de JavaScript para fines de representación visual lo 
que hace que el rendimiento de la página se mejore al usar código JavaScript para otros 
fines. Además reduce la dependencia de software de edición gráfica como \emph{Photoshop},
que sigue siendo utilizado pero su función es la edición más avanzada.

A continuación se muestra una imagen con una comparativa de la misma página web con y 
sin CSS.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm, height=7cm]{img/css-comparacion.png}
	\caption{Imagen comparativa de la misma pagina web con y sin hojas CSS}
	
	\label{fig:css}
\end{figure}

Como vemos en la figura ~\ref{fig:css} las hojas de estilo CSS permite modificar
completamente el aspecto de la pagina así como esconder menús y delimitar de manera visual 
las distintas partes de la página lo que permite mejorar la experiencia de usuario
haciendo más accesible las partes importantes de la página.


Ésta última mención a la interfaz de usuario es importante ya que es uno de los puntos
que más se cuidan en las empresas e incluso se hacen estudios para mejorar las interfaces
, por ejemplo, debido al tamaño de los nuevos \emph{smartphones} el menú de navegación
ha cambiado su posición debido a que era difícil alcanzar la parte superior de la pantalla
y por tanto se hacía molesto el uso de la aplicación.

\newpage
\section{AFRAME}
\label{sec:aframe}

\textbf{\emph{AFRAME}} es un framework web para la construcción de escenas de realidad
virtual, se creó con la intención de facilitar la creación de contenido de realidad 
virtual. Es un framework de código libre y tiene una de las comunidades de creadores de
realidad virtual más grandes actualmente.

Soporta la mayoría de gafas de realidad virtual como \emph{Vive, Rift, GearVR, etc.} 
además se puede usar no solo para realidad virtual sino para realidad aumentada. AFRAME 
fomenta la creación de escenas inmersivas completas de realidad virtual y va más allá
de únicamente generar contenido en 360º, también implementa el uso de control de posición 
y controladores (mandos) que permiten interactuar con la escena, estos controles permiten
al usuario tener una experiencia más inmersiva en la escena.

AFRAME además está soportado en los siguientes escenarios:
\begin{itemize}
	\item Realidad virtual en aplicaciones de escritorio con \emph{gadgets}.
	\item Realidad virtual en aplicaciones móviles con \emph{gadgets}.
	\item Aplicaciones de escritorio convencionales.
	\item Aplicaciones de móvil convencionales.
\end{itemize}

\newpage

A continuación se explican en subsecciones las características más importantes del 
framework AFRAME.

\subsection{Primitivas y HTML}
\label{subsec:aframe_primitivas}

\emph{AFRAME} está basado en HTML y el DOM \emph{(Document Object Model)}, HTML es un lenguaje
sencillo de leer y conocer la estructura, además no requiere de instalaciones únicamente se compone
de texto y un navegador que muestre la página. AFRAME es compatible con la mayoría de frameworks
que se utilizan actualmente en el desarrollo web como pueden ser Vue.js, React, AngularJS y jQuery.

Crear escenas de realidad virtual de manera muy simple, como se ve en la figura~\ref{fig:aframe-scene}
únicamente se necesita una etiqueta \textbf{script} que haga referencia al código del framework y una
etiqueta \textbf{a-scene} dentro del cuerpo del documento para crear una simple escena. 

AFRAME ofrece un conjunto de elementos básicos para la escena llamados primitivas, estos elementos
son figuras básicas como \emph{cajas, esferas, cilindros, planos, cielo, etc.} AFRAME no solo ofrece
figuras básicas, como hemos comentado anteriormente su intención es la de crear escenas inmersivas
completas, por ello ofrece además etiquetas para la inyección de sonidos y vídeos dentro de la escena.

Este tipo de primitivas son bastante útiles para su uso en escenas simples, todas ellas heredan 
de la primitiva \textbf{a-entity} que, equiparandolo con HTML convencional, equivaldría con la
etiqueta \textbf{div} del estándar HTML, la cual se utiliza de muchas maneras distintas.

Esta etiqueta \textbf{a-entity} representa por tanto el punto de partida de cualquier tipo de elemento
de la escena que queramos crear al cual se le irán añadiendo \emph{componentes} que le dotarán de
cierta funcionalidad específica.

AFRAME permite además crear nuestras propias primitivas lo que nos permite seguir el principio de 
programación \emph{DRY (Don't Repeat Yourself)} por el cual si tenemos un complicado elemento en la
escena que está compuesto de varias entidades distintas no tenemos que copiar ese código \emph{N} veces
sino que podemos registrar la primitiva y hacer referencia a este elemento mediante el nombre de 
etiqueta que más convenga.

La figura ~\ref{fig:aframe-scene} muestra todo el código necesario para crear la escena mostrada.
\begin{figure}[h]
	\centering
	\includegraphics[width=13cm, height=4cm]{img/html-aframe.png}
	\includegraphics[width=13cm, height=6cm]{img/aframe-scene.png}
	\caption{Ejemplo de código HTML que renderiza una escena básica de realidad 
	virtual}
	\label{fig:aframe-scene}
\end{figure}
	
	
	
\subsection{Sistema Entidad-Componente}
\label{subsec:entidad_componente}
AFRAME se basa en el framework \emph{\textbf{three.js}} y provee una estructura reutilizable de entidad-
componente en la que un componente puede ser utilizado en distintas entidades de distinta clase.
Se pueden generar componentes personalizados y vincularlos a cualquier tipo de 
entidad dándole una funcionalidad distinta. Esto permite una gran flexibilidad a la 
hora de generar distintos integrantes en la escena con funcionalidades diferentes
pero heredando todos de una misma entidad.

La arquitectura entidad-componente es común en el desarrollo 3D y en el desarrollo de videojuegos y 
sigue el principio de composición por herencia. Los beneficios de este tipo de arquitectura son:

\begin{itemize}
	\item Gran flexibilidad a la hora de crear objetos debido a la reutilización de componentes y 
	el mezclado de distintos componentes.
	\item Elimina el problema de largas cadenas de herencia, cada componente es independiente.
	\item Diseño limpio gracias al desarrollo por módulos.
	\item Es la manera más escalable de generar complejas escenas de realidad virtual.
	\item Permite reutilizar y compartir componentes no solo en un mismo proyecto sino con la comunidad
	de desarrolladores.
\end{itemize}

En la figura ~\ref{fig:ecs} se muestra un esquema del \emph{Sistema Entidad-Componente} en el cual
tenemos una figura final con forma de caja la cual estaría compuesta de varios componentes distintos. 
Estos componentes son: \textbf{Posición, Geometría, Material y Color}.

\begin{figure}
\centering
	\includegraphics[width=15cm, height=3cm]{img/ecs.png}
	\caption{La siguiente figura muestra etiquetas que serían el equivalente en AFRAME a un componente,
	el conjunto de varios componentes dan forma a la caja}
	\label{fig:ecs}
\end{figure}

A continuación se mostrará la API \emph{(Application Program Interface)} que ofrece AFRAME para 
implementar el \textbf{Sistema Entidad-Componente}:
\begin{itemize}
	\item \textbf{Entidad:} se representa en AFRAME mediante la etiqueta \textbf{a-entity}.
	\item \textbf{Componentes:} se representa en AFRAME como atributos de la etiqueta HTML. Estos 
	componentes son objetos que contienen un esquema, manejadores y métodos. Éstos se registran mediante
	el método \textbf{AFRAME.registerComponent(nombre, definición);}. A continuación se muestra un 
	componente que imprime un mensaje en la consola del navegador.
	\begin{figure}[h]
		\centering
		\includegraphics[width=12cm, height=3cm]{img/componente-aframe.png}
		\caption{Componente básico que imprime por la consola del navegador el mensaje que se le pase
		por \emph{message}}		
		\label{fig:componente}
	\end{figure}
	
	\item \textbf{Sistema:} representado por la escena mediante la etiqueta \textbf{a-scene}. Los 
	sistemas son similares a los componentes a la hora de definirlos, se registran mediante
	\textbf{AFRAME.registerSystem(nombre, definición)}.
\end{itemize}

Además como hemos comentado AFRAME tiene dos tipos de implementaciones que le dan características 
adicionales al sistema entidad-componente y es que al implementarse sobre HTML y JavaScript tenemos
dos características importantes:

\begin{itemize}
	\item Referenciar una entidad mediante el método \textbf{querySelector} implementado en JavaScript
	lo que permite acceder a una entidad por su ID, clase o atributos. En la figura ~\ref{fig:querySel}
	se muestra un ejemplo de código JavaScript que accede a un elemento de AFRAME con ID
	\emph{rightHand}.
	\begin{figure}[h]
		\centering
		\includegraphics[width=13cm, height=0.5cm]{img/querySelector-aframe.png}
		\caption{Ejemplo de acceso a un elemento de AFRAME, como se aprecia se hace de la misma
		manera que se accede a cualquier elemento de HTML convencional}
		\label{fig:querySel}
	\end{figure}
	
	\item Comunicación entre las entidades mediante eventos, esta característica es hereditaria del 
	lenguaje utilizado lo que permite registrar y suscribir eventos que permite que los elementos en
	la escena no se conozcan entre sí.
	
	\item Crear, eliminar y modificar atributos mediante el API del DOM, podemos utilizar los métodos
	\textbf{.setAttribute, .removeAttribute, .createElement y .removeChild} para modificar los 
	elementos.
	
\end{itemize}

Por último pero no más importante, los componentes pueden hacer cualquier cosa, tienen acceso completo
a \textbf{three.js, JavaScript y APIs Web} como pueden ser \emph{WebRTC, AJAX, etc.}

\subsection{Modelos 3-D}
\label{subsec:modelos-3d}

\textbf{AFRAME} ofrece la posibilidad de cargar modelos 3D más sofisticados en los formatos 
\emph{glTF, OBJ, COLLADA}. Se recomienda el uso del formato \emph{glTF} ya que es el modelo estándar
para transmitir modelos 3D en la WEB. Los componentes se pueden escribir de manera que se pueda manejar
cualquier tipo de formato que tenga un objeto en \emph{three.js} para cargar el modelo.

Los modelos son archivos en texto plano y contiene vértices, caras, texturas, materiales y animaciones.

Como se ha repetido en varias ocasiones se trata de crear escenas, para ello es necesario implementar 
animaciones. Estas animaciones se implementan con el paquete de componentes creado por
\textbf{Don McCurdy}, se puede localizar en \url{https://github.com/donmccurdy/aframe-extras/blob/master/src/loaders/animation-mixer.js}.

\subsection{Herramientas de Desarrollo}
\label{subsec:devtools}

\textbf{AFRAME} como hemos comentado se construye sobre JavaScript y HTML por tanto utiliza las mismas
herramientas de desarrollo ya disponibles dentro del navegador. Además al crear escenas 3D se hace 
complicado depurar la escena y saber que todo está siendo representado en su posición correcta, para 
esta problemática AFRAME incluye un inspector visual que permite conocer la posición y los valores de 
los atributos para cada entidad de la escena. La figura ~\ref{fig:aframe-scene} muestra la escena de
nuestro simulador y los atributos de la cámara incluida dentro del robot, como se ve el inspector
muestra el ángulo de visión de la cámara del robot y muestra los ejes de la escena respectivo al punto
en el que se encuentra de la cámara.\\

Ofrece una representación en árbol de la escena siguiendo la estructura del documento HTML, el inspector
ofrece la posibilidad de mover, rotar, añadir y borrar elementos de la escena así como copiar la 
etiqueta una vez movida para usarla en nuestro documento HTML. Un ejemplo de esto sería mover nuestro
robot y orientarlo de cara a la pelota verde, sin el inspector tendríamos que ir haciendo pruebas 
modificando manualmente el atributo de la posición dentro del documento HTML pero con el inspector 
visual basta usar las herramientas para mover el elemento y copiar las coordenadas que aparecen
en la ventana de la derecha.

Por último el inspector permite hacer capturas de movimiento lo que permite:
\begin{itemize}
	\item Test más rápidos, no se necesitan utilizar los \emph{gadgets} cada vez que se quiera hacer 
	un test lo que acelera mucho el desarrollo de la aplicación.
	
	\item Múltiples desarrolladores pueden utilizar el mismo \emph{gadget}, puedes grabar el movimiento
	y dejar de usar el \emph{gadget} para que otros desarrolladores del mismo proyecto puedan usarlo.
	
	\item Mostrar errores del código.	
	
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=15cm, height=7cm]{img/aframe-inspector.png}
	\caption{Inspector visual que ofrece el framework \emph{AFRAME}}
\end{figure}


\newpage
\section{ACE Editor}
\label{sec:ace_editor}

\textbf{\emph{ACE Editor}} es un editor de código embebido creado en \emph{JavaScript}, implementa las 
características de los editores nativos como \emph{Sublime Text, Vim, etc.} \emph{ACE} es el editor
usado en el servicio \emph{AWS Cloud9 IDE}.

El editor ofrece la siguiente funcionalidad:
\begin{itemize}
	\item Mantener el estado de la sesión como por ejemplo el \emph{scroll}, selección de texto, etc.
	\item Resaltado de sintaxis para la mayoría de lenguajes de programación como \emph{JavaScript, CSS
	, Python, Java, etc.}
	\item Permite crear tus propias reglas de resaltado.
	\item Indentación automática del código.
	\item Manejo de ficheros grandes, maneja miles de líneas sin problema.
	\item Resaltado de paréntesis.
	\item \emph{Drag and Drop} de texto dentro del editor de código.
	\item Comprobación de sintaxis del lenguaje, esta característica es bastante útil ya que nos permite
	descartar errores en ejecución debido a la sintaxis del programa lo que acelera el desarrollo.
\end{itemize}

La característica más importante para nuestro proyecto es sin duda la facilidad para embeberlo dentro
de nuestra aplicación, simplemente hace falta una etiqueta \textbf{script} y un pequeño código para
configurar su carga en la página, el detalle del código se mostrará en el capítulo \ref{chap:disenno}.
El editor además provee de una sencilla \emph{API} para poder obtener el código escrito en el editor
a través de nuestro programa para poder manejarlo.

En la figura a continuación se muestra las posibles configuraciones que puede adoptar el editor.

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm, height=6cm]{img/ace-config.png}
	\caption{Posibles parámetros de configuración para el editor}
	\label{fig:ace-conf}
\end{figure}


El editor utiliza el DOM \emph{(Document Object Model)} para el renderizado, concretamente la etiqueta
\textbf{canvas} y no depende de librerías externas. La característica más destacable de el editor es que 
no es necesario instalar nada tu ordenador, el editor reside completamente en la página web lo que 
permite la creación de aplicaciones interactivas como la del presente proyecto en la cual podemos 
programar el robot 'en vivo' sin la necesidad de tener que exportar el código de nuestro editor para 
hacer pruebas en la simulación.


\newpage
\section{Blockly}
\label{sec:blockly}

\textbf{\emph{Blockly}} es una librería que permite aprender programación mediante el uso de bloques
visuales que se pueden combinar y traducir posteriormente a distintos lenguajes. Permite
a los usuarios programar en distintos lenguajes sin tener que conocer la sintaxis del lenguaje al 
detalle.\\

Es una forma de aprender a programar orientada a estudiantes de temprana edad, el objetivo es que el 
alumno pueda aprender la lógica de los algoritmos de programación pero sin tener que aprender todo el
lenguaje como puede ser declaración de variables, tipo y en general la sintaxis propia del lenguaje
que según el tipo de lenguaje puede ser pesado al principio.

\emph{Blockly} es la base de otros entornos de programación visual como \emph{\textbf{Scratch 3}} ya
que es código libre lo que permite a cualquier desarrollador contribuir y utilizarlo en su propia 
aplicación. Ofrece métodos para importar y exportar el código de bloques además de métodos para 
modificar y personalizar el aspecto de los bloques para que sigan el estilo de la interfaz de 
la aplicación.

Es una tecnología orientada completamente al lado cliente y se puede utilizar mediante el fichero 
comprimido del repositorio oficial de \emph{Blockly} llamado \emph{blockly-compressed}, no 
utiliza dependencias y como ya hemos comentado es código libre.

\subsection{Generadores de código}
\label{subsec:blockly-generadores}

\emph{Blockly} como hemos comentado provee de generadores de código para los siguientes lenguajes:
\begin{itemize}
	\item JavaScript.
	\item Python.
	\item PHP.
	\item Lua.
	\item Dart
\end{itemize}

Estos generadores proveen las herramientas básicas para crear funciones, expresiones lógicas, bucles,
etc. La problemática de esto es que a veces nuestras aplicaciones necesitan usar la API de otras 
dependencias como en nuestro caso, para solventar esto \emph{Blockly} permite generar bloques 
personalizados que se traducirán a la instrucción necesaria dotando de mucha flexibilidad al entorno.\\

Además \emph{Blockly} permite añadir palabras reservadas dentro de cada tipo de lenguaje lo cual 
nos permite un control de colisiones con las variables propias de la aplicación ya que en lugar de 
eliminar esta variable lo que hace \emph{Blockly} es renombrar todas las apariciones de la variable 
en el código generado dinámicamente.\\

Se puede apreciar que el código generado a través de los bloques será correcto en su sintaxis pero hay
una problemática presente en programación y es la aparición de \emph{bucles infinitos}, la librería 
dota de un método para intentar aplacar esta problemática, en la figura ~\ref{fig:loop-trap} se muestra
un simple código que cuenta el número de iteraciones del bucle, no es el mejor método para solventar el 
problema ya que, como es nuestro caso, necesitaremos bucles de ejecución continua pero dota a la 
aplicación de control de ejecución de código.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, height=1.2cm]{img/loop-trap.png}
	\caption{Implementación de un contador para evitar bucles infinitos al traducir lenguaje de 
	\emph{Blockly}}
	\label{fig:loop-trap}
\end{figure}

\subsection{Bloques personalizados}
\label{subsec:custom-blocks}

Como se ha hecho referencia en la sección anterior, \emph{Blockly} permite además de generar código 
en distintos lenguajes también crear bloques personalizados lo que permite generar código a través de 
bloques y conectarlos con cualquier tipo de API.\\

Para generar bloques personalizados \emph{Blockly} hemos de configurar varios aspectos:

\begin{itemize}
	\item Configuración de los parámetros de entrada y salida del bloque, conectores o parámetros
	en línea y color. La configuración del bloque se permite mediante dos formas distintas a través
	de un JSON o mediante JavaScript registrando un nuevo bloque en el objeto \textbf{Blockly}. La 
	figura ~\ref{fig:block-definition} muestra ambos métodos para generar el mismo bloque.
	\begin{figure}[h]
		\centering
		\includegraphics[width=10cm, height=5cm]{img/block-json.png}
		\includegraphics[width=10cm, height=3cm]{img/block-js.png}
		\caption{Modos de configuración de un bloque personalizado en \emph{Blockly}, como se puede 
		apreciar la declaración de las distintas partes del bloque es bastante intuitiva y los
		parámetros son autodescriptivos.}
		\label{fig:block-definition}
	\end{figure}
	
	\item Configuración de la traducción del bloque a la instrucción de interés en los distintos 
	lenguajes necesarios. 
	
	\item Iniciar el bloque para que se renderice en el editor de bloques visual. La figura 
	~\ref{fig:block-init}
	\begin{figure}[h]
		\centering
		\includegraphics[width=6cm, height=3cm]{img/block-init.png}
		\caption{Muestra del código que inicia el bloque para que se muestre en el editor visual, 
		\emph{moveBlock} representa un objeto JSON con la configuración del bloque}
		\label{fig:block-init}
	\end{figure}
	
\end{itemize}

Como se ve aunque los parámetros del JSON son autodescriptivos y sencillos de entender es complicado
y lento generar un bloque desde cero por tanto \emph{Google} ofrece unas herramientas para 
desarrolladores en línea lo que permite acelerar esta generación de código.


En la figura ~\ref{fig:dev-tool} se muestra una imagen del entorno de creación de bloques personalizados 
que provee \emph{Blockly} en el cual se puede observar en la parte de la derecha el archivo en formato
\emph{JSON} \emph{(JavaScript Object Notation)} de configuración del bloque en el que se definen las 
entradas que toma, el color con el que se mostrará entre otra serie de parámetros. Además, muestra
la función con la configuración básica para obtener los parámetros que se utilizaran para generar
código real JavaScript.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, height=7cm]{img/custom-block.png}
	\caption{Herramienta de desarrollo para generación de bloques personalizados.}
	\label{fig:dev-tool}
\end{figure}

Como se ve en la figura ~\ref{fig:dev-tool} en la parte superior derecha la herramienta te muestra cómo
se verá el bloque final en tu aplicación bajo la configuración visual por defecto que trae 
\emph{Blockly}

\subsection{Menú de bloques, \emph{Toolbox}}

El editor de \emph{Blockly} provee además de una barra de herramientas en la cual se muestran los 
bloques que podrán ser usados a través del editor, estos bloques se configuran a través de un fichero 
XML en el cual podemos tener distintos tipos de etiquetas que se muestran a continuación.

\begin{figure}
	\centering
	\includegraphics[width=11cm, height=2cm]{img/toolbox-xml.png}
	\caption{Ejemplo de las etiquetas posibles de configuración de la \emph{toolbox} del editor}
	\label{fig:xml-toolbox}
\end{figure}

Como vemos en la figura ~\ref{fig:xml-toolbox} tenemos tres bloques distintos, la raíz del XML marcada
por la etiqueta \emph{xml}, la etiqueta \emph{category} que nos permite hacer divisiones de bloques por
tipos distintos, en la imagen tenemos dos categorías \emph{variables y texto}, la categoría 
\emph{variables} como vemos no tiene bloques dentro ya que se generan dinámicamente. En la categoría
\emph{texto} vemos declarado un bloque de tipo \emph{text} que representaría un \emph{String} en 
lenguaje JavaScript. Como se puede apreciar la configuración del menú de bloques no es fija, se puede
crear distintas categorías en función del diseño de la interfaz de usuario.

\section{jQuery}
\label{sec:jquery}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
\label{chap:disenno}

Aquí viene todo lo que has hecho tú (tecnológicamente).
Puedes entrar hasta el detalle.
Es la parte más importante de la memoria, porque describe lo que has hecho tú.
Eso sí, normalmente aconsejo no poner código, sino diagramas.

\section{Arquitectura}
\label{sec:arquitectura}

Si tu proyecto es un software, siempre es bueno poner la arquitectura (que es cómo se estructura tu programa a ``vista de pájaro'').

Por ejemplo, puedes verlo en la figura~\ref{fig:arquitectura}.

\begin{figure}
  \centering
  \includegraphics[width=9cm, keepaspectratio]{img/arquitectura}
  \caption{Estructura del parser básico}
  \label{fig:arquitectura}
\end{figure}

Si utilizas una base de datos, no te olvides de incluir también un diagrama de entidad-relación.

\section{Objeto Robot}
\label{sec:robot}

\subsection{Motores}
\label{subsec:motores}

\subsection{Sensores}
\label{subsec:sensores}

\subsection{Cámara}
\label{subsec:camara}

\section{Interfaz}
\label{sec:interfaz}

\section{Funcionalidad del servidor}
\label{sec:servidor}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% USO DEL SIMULADOR %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Usos del simulador}
\label{chap:usos}

\section{Ejercicios JdeRobot Kids}
\label{sec:ejercicios}

\section{Robot real}
\label{sec:robot_real}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}

Esta sección es la sección espejo de las dos primeras del capítulo de objetivos, donde se planteaba el objetivo general y se elaboraban los específicos.

Es aquí donde hay que debatir qué se ha conseguido y qué no.
Cuando algo no se ha conseguido, se ha de justificar, en términos de qué problemas se han encontrado y qué medidas se han tomado para mitigar esos problemas.


\section{Valoración objetivo final}
\label{sec:valoracion_objetivo_final}

\section{Aplicación de lo aprendido}
\label{sec:aplicacion_aprendido}

Aquí viene lo que has aprendido durante el Grado/Máster y que has aplicado en el TFG/TFM. Una buena idea es poner las asignaturas más relacionadas y comentar en un párrafo los conocimientos y habilidades puestos en práctica.

\begin{enumerate}
  \item a
  \item b
\end{enumerate}


\section{Mejoras futuras}
\label{sec:mejoras_futuras}

Ningún software se termina, así que aquí vienen ideas y funcionalidades que estaría bien tener implementadas en el futuro.

Es un apartado que sirve para dar ideas de cara a futuros TFGs/TFMs.

\section{Autovaloración del proyecto}
\label{sec:autovaloracion}


Aquí viene lo que has aprendido en el Trabajo Fin de Grado/Máster.

\begin{enumerate}
  \item a
  \item b
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Manual de usuario}
\label{app:manual}

\chapter{Enlaces a tutoriales de uso}
\label{app:tutoriales}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información:
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
